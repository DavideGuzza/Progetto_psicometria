)
)
# Filtra i dati per il tempo desiderato (es. 200 ms)
data_200ms <- eeg_data %>%
filter(near(time_sec, 0.2, tol = 0.001))  # 200 ms ± 1 ms
# Crea l'oggetto eeg_epochs con parametri espliciti
eeg_data <- eeg_epochs(
data = dati_epoched,
srate = 1000,  # Modifica con la tua frequenza di campionamento
chan_info = "channel",
timings = c(-0.2, 0.8),  # Start e end delle epoche (in secondi)
events = data.frame(
event_time = 0,  # Tempo dell'evento (0 = inizio stimolo)
event_type = unique(dati_epoched$condition)
)
)
str(eeg_data)
dput(head(eeg_data, 10))
str(eeg_data)
# Filtra i dati per il tempo desiderato (es. 200 ms)
data_200ms <- eeg_data %>%
filter(near(time_sec, 0.2, tol = 0.001))  # 200 ms ± 1 ms
table(dati$channel)
data("electrode_locations")
electrode_coords <- tribble(
~channel, ~x,    ~y,     # Descrizione posizione
"FP1",   -0.35,  0.9,    # Frontopolar sinistro
"FP2",    0.35,  0.9,    # Frontopolar destro
"Fz",     0,     0.75,   # Frontale centrale
"Cz",     0,     0.3,    # Centrale
"Pz",     0,    -0.1,    # Parietale centrale
"Oz",     0,    -0.6,    # Occipitale centrale
"F3",    -0.4,   0.7,    # Frontale sinistro
"F4",     0.4,   0.7,    # Frontale destro
"C3",    -0.6,   0.3,    # Centrale sinistro
"C4",     0.6,   0.3,    # Centrale destro
"P3",    -0.4,  -0.1,    # Parietale sinistro
"P4",     0.4,  -0.1,    # Parietale destro
"O1",    -0.3,  -0.6,    # Occipitale sinistro
"O2",     0.3,  -0.6,    # Occipitale destro
"T7",    -0.8,   0.4,    # Temporale sinistro (F7 in alcuni sistemi)
"T8",     0.8,   0.4,    # Temporale destro (F8 in alcuni sistemi)
"PO7",   -0.5,  -0.4,    # Parieto-occipitale sinistro
"PO8",    0.5,  -0.4     # Parieto-occipitale destro
)
ggplot(electrode_coords, aes(x = x, y = y, label = channel)) +
geom_point() +
geom_text(vjust = -1) +
geom_head() +  # Aggiunge il contorno della testa (da eegUtils)
coord_fixed() +
labs(title = "Disposizione Elettrodi 10-20")
length(table(dati$channel))
table(dati$channel)
remotes::install_github("bnicenboim/eeg_positions")
devtools::install_github("bnicenboim/eeg_positions")
devtools::install_github("bnicenboim/eeguana")
library(eeguana)
data("electrode_locations")
eeguana::data_faces_ERPs
unique(dati$channel)
electrode_coords <- data.frame(
electrode = c("FP1", "F3", "F7", "FC3", "C3", "C5", "P3", "P7", "PO7", "PO3",
"O1", "Oz", "Pz", "CPz", "FP2", "Fz", "F4", "F8", "FC4", "FCz",
"Cz", "C4", "C6", "P4", "P8", "PO8", "PO4", "O2"),
x = c(-0.23, -0.50, -0.71, -0.50, -0.71, -0.87, -0.50, -0.71, -0.38, -0.23,
-0.13, 0.00, 0.00, 0.00, 0.23, 0.00, 0.50, 0.71, 0.50, 0.00,
0.00, 0.71, 0.87, 0.50, 0.71, 0.38, 0.23, 0.13),
y = c(0.91, 0.85, 0.71, 0.45, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91,
-0.98, -1.00, -0.50, 0.00, 0.91, 0.85, 0.85, 0.71, 0.45, 0.53,
0.00, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91, -0.98)
)
ggplot(electrode_coords, aes(x = x, y = y, label = electrode)) +
geom_point(size = 3) +
geom_text(vjust = -0.8, size = 3) +
coord_fixed() +  # Ensures aspect ratio is maintained
labs(title = "Electrode Coordinates (2D Projection)")
ggplot(electrode_coords, aes(x = x, y = y, label = electrode)) +
geom_point(size = 3) +
geom_text(vjust = -0.8, size = 3) +
coord_fixed() +  # Ensures aspect ratio is maintained
labs(title = "Electrode Coordinates (2D Projection)")
topoplot(data = your_erp_data, chanLocs = electrode_coords)
library(eegUtils)
topoplot(data = dati, chanLocs = electrode_coords)
ggplot(electrode_coords, aes(x = x, y = y, label = electrode)) +
geom_point(size = 3) +
geom_text(vjust = -0.8, size = 3) +
coord_fixed() +  # Ensures aspect ratio is maintained
labs(title = "Electrode Coordinates (2D Projection)")
library(eegUtils)
# Converti il tempo in secondi e definisci le epoche
dati_epoched <- dati %>%
mutate(
time_sec = time / 1000,  # Converti ms -> secondi
epoch = paste(id, condition, sep = "_")  # Crea un ID unico per epoca
)
# Crea l'oggetto eeg_epochs con parametri espliciti
eeg_data <- eeg_epochs(
data = dati_epoched,
srate = 1000,  # Modifica con la tua frequenza di campionamento
chan_info = "channel",
timings = c(-0.2, 0.8),  # Start e end delle epoche (in secondi)
events = data.frame(
event_time = 0,  # Tempo dell'evento (0 = inizio stimolo)
event_type = unique(dati_epoched$condition)
)
)
# Filtra i dati per il tempo desiderato (es. 200 ms)
data_200ms <- eeg_data %>%
filter(near(time_sec, 0.2, tol = 0.001))  # 200 ms ± 1 ms
# 1. Converti il tempo in secondi e definisci le epoche
dati_epoched <- dati %>%
mutate(
time_sec = time / 1000,  # Converti ms -> secondi
epoch = paste(id, condition, sep = "_")  # Crea un ID unico per epoca
)
# 3. Unisci le coordinate al dataset EEG
dati_epoched <- dati_epoched %>%
left_join(electrode_coords, by = "channel")
rlang::last_trace()
dati_epoched$channel
table(dati_epoched$dati)
table(dati_epoched$channel)
table(electrode_coords$electrode)
electrode_coords <- data.frame(
channel = c("FP1", "F3", "F7", "FC3", "C3", "C5", "P3", "P7", "PO7", "PO3",
"O1", "Oz", "Pz", "CPz", "FP2", "Fz", "F4", "F8", "FC4", "FCz",
"Cz", "C4", "C6", "P4", "P8", "PO8", "PO4", "O2"),
x = c(-0.23, -0.50, -0.71, -0.50, -0.71, -0.87, -0.50, -0.71, -0.38, -0.23,
-0.13, 0.00, 0.00, 0.00, 0.23, 0.00, 0.50, 0.71, 0.50, 0.00,
0.00, 0.71, 0.87, 0.50, 0.71, 0.38, 0.23, 0.13),
y = c(0.91, 0.85, 0.71, 0.45, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91,
-0.98, -1.00, -0.50, 0.00, 0.91, 0.85, 0.85, 0.71, 0.45, 0.53,
0.00, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91, -0.98)
)
ggplot(electrode_coords, aes(x = x, y = y, label = channel)) +
geom_point(size = 3) +
geom_text(vjust = -0.8, size = 3) +
coord_fixed() +  # Ensures aspect ratio is maintained
labs(title = "Electrode Coordinates (2D Projection)")
# 3. Unisci le coordinate al dataset EEG
dati_epoched <- dati_epoched %>%
left_join(electrode_coords, by = "channel")
# 4. Crea l'oggetto eeg_epochs
eeg_data <- eeg_epochs(
data = dati_epoched,
srate = 1000,  # Frequenza di campionamento (adatta al tuo dato)
chan_info = "channel",
timings = c(-0.2, 0.8),  # Start e end delle epoche (in secondi)
events = data.frame(
event_time = 0,  # Tempo dell'evento (0 = inizio stimolo)
event_type = unique(dati_epoched$condition)
)
)
# 5. Filtra i dati per il tempo desiderato (200 ms)
data_200ms <- eeg_data$signals %>%  # Accedi alla tibble dei segnali
filter(near(time_sec, 0.2, tol = 0.001))  # 200 ms ± 1 ms
# 6. Genera il plot topografico
ggplot(data_200ms, aes(x = x, y = y, fill = value)) +
geom_topo() +  # Usa le coordinate x/y
geom_head(size = 1.5) +  # Contorno della testa (regola 'size' se necessario)
scale_fill_gradient2(
low = "blue",
mid = "white",
high = "red",
midpoint = 0  # Punto medio per la scala di colore
) +
labs(
title = "Topografia a 200 ms",
fill = "Amplitudine (µV)"
) +
theme_minimal()
topoplot(
filter(eeg_data$signals, near(time_sec, 0.2, tol = 0.001)),
interp = TRUE,
palette = "RdBu",
limits = c(-5, 5)  # Adatta i limiti ai tuoi dati
)
electrode_coords <- data.frame(
electrode = c("FP1", "F3", "F7", "FC3", "C3", "C5", "P3", "P7", "PO7", "PO3",
"O1", "Oz", "Pz", "CPz", "FP2", "Fz", "F4", "F8", "FC4", "FCz",
"Cz", "C4", "C6", "P4", "P8", "PO8", "PO4", "O2"),
x = c(-0.23, -0.50, -0.71, -0.50, -0.71, -0.87, -0.50, -0.71, -0.38, -0.23,
-0.13, 0.00, 0.00, 0.00, 0.23, 0.00, 0.50, 0.71, 0.50, 0.00,
0.00, 0.71, 0.87, 0.50, 0.71, 0.38, 0.23, 0.13),
y = c(0.91, 0.85, 0.71, 0.45, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91,
-0.98, -1.00, -0.50, 0.00, 0.91, 0.85, 0.85, 0.71, 0.45, 0.53,
0.00, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91, -0.98)
)
topoplot(
filter(eeg_data$signals, near(time_sec, 0.2, tol = 0.001)),
interp = TRUE,
palette = "RdBu",
limits = c(-5, 5)  # Adatta i limiti ai tuoi dati
)
names(dati)
names(dati)[2]<-"electrode"
names(dati)
topoplot(
filter(eeg_data$signals, near(time_sec, 0.2, tol = 0.001)),
interp = TRUE,
palette = "RdBu",
limits = c(-5, 5)  # Adatta i limiti ai tuoi dati
)
names(dati)[2]<-"channel"
# 6. Genera il plot topografico
ggplot(data_200ms, aes(x = x, y = y, fill = value)) +
geom_topo() +  # Usa le coordinate x/y
geom_head(size = 1.5) +  # Contorno della testa (regola 'size' se necessario)
scale_fill_gradient2(
low = "blue",
mid = "white",
high = "red",
midpoint = 0  # Punto medio per la scala di colore
) +
labs(
title = "Topografia a 200 ms",
fill = "Amplitudine (µV)"
) +
theme_minimal()
# 6. Genera il plot topografico
ggplot(data_200ms, aes(x = x, y = y, z = value, fill = value)) +  # Aggiungi z = value
geom_topo(interp = TRUE) +  # Specifica l'interpolazione
geom_head(size = 1.5) +
scale_fill_gradient2(
low = "blue",
mid = "white",
high = "red",
midpoint = 0
) +
labs(title = "Topografia a 200 ms")
electrode_coords_3d <- data.frame(
channel = c("FP1", "F3", "F7", "FC3", "C3", "C5", "P3", "P7", "PO7", "PO3",
"O1", "Oz", "Pz", "CPz", "FP2", "Fz", "F4", "F8", "FC4", "FCz",
"Cz", "C4", "C6", "P4", "P8", "PO8", "PO4", "O2"),
x = c(-0.23, -0.50, -0.71, -0.50, -0.71, -0.87, -0.50, -0.71, -0.38, -0.23,
-0.13, 0.00, 0.00, 0.00, 0.23, 0.00, 0.50, 0.71, 0.50, 0.00,
0.00, 0.71, 0.87, 0.50, 0.71, 0.38, 0.23, 0.13),
y = c(0.91, 0.85, 0.71, 0.45, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91,
-0.98, -1.00, -0.50, 0.00, 0.91, 0.85, 0.85, 0.71, 0.45, 0.53,
0.00, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91, -0.98),
z = c(-0.34, 0.17, 0.00, 0.74, 0.71, 0.43, 0.74, 0.00, -0.08, 0.34,
0.15, 0.00, 0.87, 1.00, -0.34, 0.53, 0.17, 0.00, 0.74, 0.85,
1.00, 0.71, 0.43, 0.74, 0.00, -0.08, 0.34, 0.15)
)
ggplot(electrode_coords, aes(x = x, y = y, label = electrode)) +
geom_point(size = 3) +
geom_text(vjust = -0.8, size = 3) +
coord_fixed() +  # Ensures aspect ratio is maintained
labs(title = "Electrode Coordinates (2D Projection)")
library(plotly)
plot_ly(electrode_coords_3d, x = ~x, y = ~y, z = ~z, text = ~electrode, type = "scatter3d", mode = "markers+text") %>%
layout(scene = list(aspectmode = "cube"))
plot_ly(electrode_coords_3d, x = ~x, y = ~y, z = ~z, text = ~channel, type = "scatter3d", mode = "markers+text") %>%
layout(scene = list(aspectmode = "cube"))
# Genera il plot
ggplot(data_200ms, aes(x = x, y = y, fill = value)) +
geom_topo() +  # Richiede le coordinate x/y degli elettrodi
geom_head() +  # Aggiunge il contorno della testa
scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
labs(title = "Topografia a 200 ms")
electrode_coords_3d <- data.frame(
channel = c("FP1", "F3", "F7", "FC3", "C3", "C5", "P3", "P7", "PO7", "PO3",
"O1", "Oz", "Pz", "CPz", "FP2", "Fz", "F4", "F8", "FC4", "FCz",
"Cz", "C4", "C6", "P4", "P8", "PO8", "PO4", "O2"),
x = c(-0.23, -0.50, -0.71, -0.50, -0.71, -0.87, -0.50, -0.71, -0.38, -0.23,
-0.13, 0.00, 0.00, 0.00, 0.23, 0.00, 0.50, 0.71, 0.50, 0.00,
0.00, 0.71, 0.87, 0.50, 0.71, 0.38, 0.23, 0.13),
y = c(0.91, 0.85, 0.71, 0.45, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91,
-0.98, -1.00, -0.50, 0.00, 0.91, 0.85, 0.85, 0.71, 0.45, 0.53,
0.00, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91, -0.98),
z = c(-0.34, 0.17, 0.00, 0.74, 0.71, 0.43, 0.74, 0.00, -0.08, 0.34,
0.15, 0.00, 0.87, 1.00, -0.34, 0.53, 0.17, 0.00, 0.74, 0.85,
1.00, 0.71, 0.43, 0.74, 0.00, -0.08, 0.34, 0.15)
)
#devtools::install_github("craddm/eegUtils")
library(eegUtils)
# Converti il tempo in secondi e definisci le epoche
dati_epoched <- dati %>%
mutate(
time_sec = time / 1000,  # Converti ms -> secondi
epoch = paste(id, condition, sep = "_")  # Crea un ID unico per epoca
)
# Crea l'oggetto eeg_epochs con parametri espliciti
eeg_data <- eeg_epochs(
data = dati_epoched,
srate = 1000,  # Modifica con la tua frequenza di campionamento
chan_info = "channel",
timings = c(-0.2, 0.8),  # Start e end delle epoche (in secondi)
events = data.frame(
event_time = 0,  # Tempo dell'evento (0 = inizio stimolo)
event_type = unique(dati_epoched$condition)
)
)
# Filtra i dati per il tempo desiderato (es. 200 ms)
data_200ms <- eeg_data %>%
filter(near(time_sec, 0.2, tol = 0.001))  # 200 ms ± 1 ms
# Genera il plot
ggplot(data_200ms, aes(x = x, y = y, fill = value)) +
geom_topo() +  # Richiede le coordinate x/y degli elettrodi
geom_head() +  # Aggiunge il contorno della testa
scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
labs(title = "Topografia a 200 ms")
#| include: false
library(tidyverse)
#| echo: false
library(tidyverse)
erp_load <- function(path) {
filenames <- list.files(path = path, full.names = TRUE)
lista_dati <- vector("list", length(filenames))
for (i in seq_along(filenames)) {
tempdata <- read.table(filenames[i], header = TRUE)
temp_long <- tempdata %>%
pivot_longer(cols = -time, names_to = "channel", values_to = "value") %>%
mutate(
id = ceiling(i / 4),
condition = c("Cars", "Faces", "ScrambledCars", "ScrambledFaces")[(i - 1) %% 4 + 1]
)
lista_dati[[i]] <- temp_long  # Salva il tibble trasformato
}
df_finale <- bind_rows(lista_dati)  # Combina tutti i dati
return(df_finale)
rm(lista_dati)
}
dati <- erp_load("C:/Users/david/Downloads/ERPDataforstudents")
head(dati)
#| echo: false
dati <- dati %>%
filter(condition %in% c("Faces", "ScrambledFaces"))
plot_mean_values  <- function(data, channels_selected, conditions_selected) {
data_filtered <- data %>%
filter(channel %in% channels_selected, condition %in% conditions_selected) %>%
group_by(time, channel, condition) %>%
summarise(
mean_value = mean(value, na.rm = TRUE),
sem_value = sd(value, na.rm = TRUE) / sqrt(n())
)
if (nrow(data_filtered) == 0) {
message("Nessun dato trovato per i canali: ", paste(channels_selected, collapse = ", "),
" e le condizioni: ", paste(conditions_selected, collapse = ", "))
return(NULL)
}
ggplot(data_filtered, aes(x = time, y = mean_value, color = condition, fill = condition)) +
geom_line(linewidth = 1) +
geom_ribbon(aes(ymin = mean_value - sem_value, ymax = mean_value + sem_value), alpha = 0.2) +
facet_wrap(~ channel, scales = "free_y") +
labs(
x = "Tempo",
y = "Valore Medio",
color = "Condizione",
fill = "Condizione"
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
legend.position = "bottomleft"
)
}
all_channels <- c("C3","C4","C5","C6","CPz","Cz","F3","F4","F7","F8","FC3","FC4","FCz","FP1","FP2","Fz","O1","O2","Oz","P3","P4","P7","P8","PO3","PO4","PO7","PO8","Pz")
plot_mean_values(dati, all_channels,c("Faces","ScrambledFaces"))
#| echo: false
plot_mean_values(dati, c("F4","FC4", "F8"),c("Faces","ScrambledFaces"))
#| echo: false
plot_mean_values(dati, c("F3", "FC3", "F7"),c("Faces","ScrambledFaces"))
#| echo: false
plot_mean_values(dati, c("PO8", "P8", "PO4"),c("Faces","ScrambledFaces"))
#| echo: false
plot_mean_values(dati, c("PO7", "P7", "PO3"),c("Faces","ScrambledFaces"))
# Crea il grafico con ggplot2 e facet_wrap per più canali
ggplot(data_filtered, aes(x = time, y = mean_value, color = condition, fill = condition)) +
geom_line(linewidth = 1) +  # Linea per la media
geom_ribbon(aes(ymin = mean_value - sem_value, ymax = mean_value + sem_value), alpha = 0.2) +  # Banda errore standard
facet_wrap(~ channel, scales = "free_y") +  # Genera più grafici, uno per canale
labs(
x = "Tempo",
y = "Valore Medio",
color = "Condizione",
fill = "Condizione"
) +
theme_minimal() +  # Tema pulito
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),  # Titolo centrato
legend.position = "top"
)
library(tidyverse)
erp_load <- function(path) {
filenames <- list.files(path = path, full.names = TRUE)
lista_dati <- vector("list", length(filenames))
for (i in seq_along(filenames)) {
tempdata <- read.table(filenames[i], header = TRUE)
temp_long <- tempdata %>%
pivot_longer(cols = -time, names_to = "channel", values_to = "value") %>%
mutate(
id = ceiling(i / 4),
condition = c("Cars", "Faces", "ScrambledCars", "ScrambledFaces")[(i - 1) %% 4 + 1]
)
lista_dati[[i]] <- temp_long  # Salva il tibble trasformato
}
df_finale <- bind_rows(lista_dati)  # Combina tutti i dati
return(df_finale)
rm(lista_dati)
}
df_finale <- erp_load("C:/Users/david/Downloads/ERPDataforstudents")
plot_mean_values  <- function(data, channels_selected, conditions_selected) {
# Filtra i dati per i canali e le condizioni selezionate
data_filtered <- data %>%
filter(channel %in% channels_selected, condition %in% conditions_selected) %>%
group_by(time, channel, condition) %>%  # Aggiunto 'channel' per gestire più grafici
summarise(
mean_value = mean(value, na.rm = TRUE),  # Media dei valori
sem_value = sd(value, na.rm = TRUE) / sqrt(n())  # Errore standard della media
)
# Controlla se ci sono dati validi
if (nrow(data_filtered) == 0) {
message("Nessun dato trovato per i canali: ", paste(channels_selected, collapse = ", "),
" e le condizioni: ", paste(conditions_selected, collapse = ", "))
return(NULL)
}
# Crea il grafico con ggplot2 e facet_wrap per più canali
ggplot(data_filtered, aes(x = time, y = mean_value, color = condition, fill = condition)) +
geom_line(linewidth = 1) +  # Linea per la media
geom_ribbon(aes(ymin = mean_value - sem_value, ymax = mean_value + sem_value), alpha = 0.2) +  # Banda errore standard
facet_wrap(~ channel, scales = "free_y") +  # Genera più grafici, uno per canale
labs(
x = "Tempo",
y = "Valore Medio",
color = "Condizione",
fill = "Condizione"
) +
theme_minimal() +  # Tema pulito
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),  # Titolo centrato
legend.position = "top"
)
}
plot_mean_values(df_finale, c("F3","F4","PO7","PO8"),c("Faces","ScrambledFaces"))
library(tidyverse)
library(tidyverse)  # Assicura che dplyr sia caricato correttamente
plot_multiple_conditions <- function(data, channel_selected, conditions_selected) {
# Filtra i dati per il canale e le condizioni selezionate
data_filtered <- data %>%
filter(channel == channel_selected, condition %in% conditions_selected)
# Calcola la media per ogni condizione
data_summary <- data_filtered %>%
group_by(time, condition) %>%
summarise(
mean_value = mean(value, na.rm = TRUE),
.groups = "drop"
)
# Controlla se ci sono dati validi
if (nrow(data_summary) == 0) {
message("Nessun dato trovato per il canale: ", channel_selected,
" e le condizioni: ", paste(conditions_selected, collapse = ", "))
return(NULL)
}
# Crea il grafico
ggplot() +
# Linee nere per i singoli soggetti
geom_line(data = data_filtered, aes(x = time, y = value, group = id),
color = "black", linewidth = 0.5) +
# Linea rossa per la media
geom_line(data = data_summary, aes(x = time, y = mean_value),
color = "red", linewidth = 1.2) +
# Facet per mostrare più condizioni in grafici separati
facet_wrap(~ condition, scales = "free_y") +
labs(
title = paste("Canale:", channel_selected, "- Confronto Condizioni"),
x = "Tempo",
y = "Valore",
color = "Condizione"
) +
theme_bw() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold")
)
}
plot_multiple_conditions(df_finale, channel_selected = c("FP1"), conditions_selected = c("Cars", "Faces", "ScrambledCars", "ScrambledFaces"))
plot_mean_rect  <- function(data, channels_selected, conditions_selected) {
# Filtra i dati per i canali e le condizioni selezionate
data_filtered <- data %>%
filter(channel %in% channels_selected, condition %in% conditions_selected) %>%
group_by(time, channel, condition) %>%  # Aggiunto 'channel' per gestire più grafici
summarise(
mean_value = mean(value, na.rm = TRUE),  # Media dei valori
sem_value = sd(value, na.rm = TRUE) / sqrt(n())  # Errore standard della media
)
# Controlla se ci sono dati validi
if (nrow(data_filtered) == 0) {
message("Nessun dato trovato per i canali: ", paste(channels_selected, collapse = ", "),
" e le condizioni: ", paste(conditions_selected, collapse = ", "))
return(NULL)
}
# Crea il grafico con ggplot2 e facet_wrap per più canali
ggplot(data_filtered, aes(x = time, y = mean_value, color = condition, fill = condition)) +
geom_rect(aes(xmin = 130, xmax = 180, ymin = -Inf, ymax = Inf),
fill = "lightgrey", alpha = 0.1,color = "lightgrey", linewidth = 0.05) +
geom_line(linewidth = 1) +  # Linea per la media
geom_ribbon(aes(ymin = mean_value - sem_value, ymax = mean_value + sem_value), alpha = 0.2) +  # Banda errore standard
facet_wrap(~ channel, scales = "free_y") +  # Genera più grafici, uno per canale
labs(
x = "Tempo",
y = "Valore Medio",
color = "Condizione",
fill = "Condizione"
) +
theme_bw() +  # Tema pulito
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),  # Titolo centrato
legend.position = "top"
)
}
plot_mean_rect(df_finale, c("P7","P8"),c("Faces","ScrambledFaces"))
