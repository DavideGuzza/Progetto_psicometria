)
plot(electrode_coords$x,electrode_coords$y)
electrode_coords <- data.frame(
electrode = c("FP1", "F3", "F7", "FC3", "C3", "C5", "P3", "P7", "PO7", "PO3",
"O1", "Oz", "Pz", "CPz", "FP2", "Fz", "F4", "F8", "FC4", "FCz",
"Cz", "C4", "C6", "P4", "P8", "PO8", "PO4", "O2"),
x = c(-0.23, -0.50, -0.71, -0.50, -0.71, -0.87, -0.50, -0.71, -0.38, -0.23,
-0.13, 0.00, 0.00, 0.00, 0.23, 0.00, 0.50, 0.71, 0.50, 0.00,
0.00, 0.71, 0.87, 0.50, 0.71, 0.38, 0.23, 0.13),
y = c(0.91, 0.85, 0.71, 0.45, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91,
-0.98, -1.00, -0.50, 0.00, 0.91, 0.85, 0.85, 0.71, 0.45, 0.53,
0.00, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91, -0.98)
)
library(dplyr)
library(igraph)
# 1) Define channel adjacency from your coords
coords <- electrode_coords
# compute pairwise distances
dist_mat <- as.matrix(dist(coords[, c("x","y")]))
# pick a distance threshold (e.g. 0.5 units) so that each electrode has ~4–6 neighbors
adj_thresh <- 0.5
adj_pairs <- which(dist_mat < adj_thresh & dist_mat > 0, arr.ind = TRUE)
# turn that into a data.frame of edges
chan_edges <- tibble(
from = coords$electrode[adj_pairs[,1]],
to   = coords$electrode[adj_pairs[,2]]
)
# 2) Prepare your “nodes” = each suprathreshold point
#    give each a unique ID = paste(channel, time)
nodes <- runs_df %>%
mutate(node_id = paste(channel, time)) %>%
select(node_id, channel, time, t_obs)
runs_df <- t_df %>%
# keep only points where the test-statistic exceeds the positive OR negative cutoff
filter(t_obs >  threshold | t_obs < -threshold) %>%
# keep only the columns we need for clustering
select(channel, time, t_obs)
t_df
runs_df <- raster_df %>%
# keep only points where the test-statistic exceeds the positive OR negative cutoff
filter(t_obs >  threshold | t_obs < -threshold) %>%
# keep only the columns we need for clustering
select(channel, time, t_obs)
# 1) Define channel adjacency from your coords
coords <- electrode_coords
# compute pairwise distances
dist_mat <- as.matrix(dist(coords[, c("x","y")]))
# pick a distance threshold (e.g. 0.5 units) so that each electrode has ~4–6 neighbors
adj_thresh <- 0.5
adj_pairs <- which(dist_mat < adj_thresh & dist_mat > 0, arr.ind = TRUE)
# 2) Prepare your “nodes” = each suprathreshold point
#    give each a unique ID = paste(channel, time)
nodes <- runs_df %>%
mutate(node_id = paste(channel, time)) %>%
select(node_id, channel, time, t_obs)
# 3) Build edges between nodes
#  a) temporal edges: same channel, time difference = 1 bin
temp_edges <- nodes %>%
group_by(channel) %>%
arrange(time) %>%
mutate(next_id = lead(node_id), next_time = lead(time)) %>%
filter(!is.na(next_id) & next_time == time + unique(diff(sort(unique(runs_df$time))))) %>%
transmute(from = node_id, to = next_id)
#  b) spatial edges: same time, channels in chan_edges
# join nodes to chan_edges at each time‐point
spat_edges <- nodes %>%
select(node_id, channel, time) %>%
inner_join(chan_edges, by = c("channel" = "from")) %>%       # node’s channel -> from
rename(neigh_chan = to) %>%
inner_join(nodes %>% select(node_id, channel),                 # find node at neigh_chan
by = c("neigh_chan" = "channel", "time" = "time")) %>%
transmute(from = node_id.x, to = node_id.y)
temp_edges
#  b) spatial edges: same time, channels in chan_edges
# join nodes to chan_edges at each time‐point
spat_edges <- nodes %>%
select(node_id, channel, time) %>%
inner_join(chan_edges, by = c("channel" = "from")) %>%       # node’s channel -> from
rename(neigh_chan = to) %>%
inner_join(nodes %>% select(node_id, channel),                 # find node at neigh_chan
by = c("neigh_chan" = "channel", "time" = "time")) %>%
transmute(from = node_id.x, to = node_id.y)
temp_edges
dist_mat
adj_pairs
chan_edges
chan_edges
nodes
temp_edges
spat_edges
spat_edges <- nodes %>%
select(node_id, channel, time) %>%
inner_join(chan_edges, by = c("channel" = "from")) %>%       # node’s channel -> from
rename(neigh_chan = to) %>%
inner_join(nodes %>% select(node_id, channel),                 # find node at neigh_chan
by = c("neigh_chan" = "channel", "time" = "time")) %>%
transmute(from = node_id.x, to = node_id.y)
electrode_coords <- data.frame(
electrode = c("FP1", "F3", "F7", "FC3", "C3", "C5", "P3", "P7", "PO7", "PO3",
"O1", "Oz", "Pz", "CPz", "FP2", "Fz", "F4", "F8", "FC4", "FCz",
"Cz", "C4", "C6", "P4", "P8", "PO8", "PO4", "O2"),
x = c(-0.23, -0.50, -0.71, -0.50, -0.71, -0.87, -0.50, -0.71, -0.38, -0.23,
-0.13, 0.00, 0.00, 0.00, 0.23, 0.00, 0.50, 0.71, 0.50, 0.00,
0.00, 0.71, 0.87, 0.50, 0.71, 0.38, 0.23, 0.13),
y = c(0.91, 0.85, 0.71, 0.45, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91,
-0.98, -1.00, -0.50, 0.00, 0.91, 0.85, 0.85, 0.71, 0.45, 0.53,
0.00, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91, -0.98)
)
runs_df <- raster_df %>%
# keep only points where the test-statistic exceeds the positive OR negative cutoff
filter(t_obs >  threshold | t_obs < -threshold) %>%
# keep only the columns we need for clustering
select(channel, time, t_obs)
library(dplyr)
library(igraph)
# 1) Define channel adjacency from your coords
coords <- electrode_coords
# compute pairwise distances
dist_mat <- as.matrix(dist(coords[, c("x","y")]))
# pick a distance threshold (e.g. 0.5 units) so that each electrode has ~4–6 neighbors
adj_thresh <- 0.5
adj_pairs <- which(dist_mat < adj_thresh & dist_mat > 0, arr.ind = TRUE)
# turn that into a data.frame of edges
chan_edges <- tibble(
from = coords$electrode[adj_pairs[,1]],
to   = coords$electrode[adj_pairs[,2]]
)
# 2) Prepare your “nodes” = each suprathreshold point
#    give each a unique ID = paste(channel, time)
nodes <- runs_df %>%
mutate(node_id = paste(channel, time)) %>%
select(node_id, channel, time, t_obs)
# 3) Build edges between nodes
#  a) temporal edges: same channel, time difference = 1 bin
temp_edges <- nodes %>%
group_by(channel) %>%
arrange(time) %>%
mutate(next_id = lead(node_id), next_time = lead(time)) %>%
filter(!is.na(next_id) & next_time == time + unique(diff(sort(unique(runs_df$time))))) %>%
transmute(from = node_id, to = next_id)
#  b) spatial edges: same time, channels in chan_edges
# join nodes to chan_edges at each time‐point
spat_edges <- nodes %>%
select(node_id, channel, time) %>%
inner_join(chan_edges, by = c("channel" = "from")) %>%       # node’s channel -> from
rename(neigh_chan = to) %>%
inner_join(nodes %>% select(node_id, channel),                 # find node at neigh_chan
by = c("neigh_chan" = "channel", "time" = "time")) %>%
transmute(from = node_id.x, to = node_id.y)
#| echo: false
#| fig-width: 12
#| fig-height: 9
#| fig-align: "center"
raster_df <- combined_df %>%
mutate(
color = case_when(
t_obs >  threshold & p_adj < 0.05 ~ "white",  # significant positive
t_obs < -threshold & p_adj < 0.05 ~ "black",  # significant negative
TRUE                              ~ "grey80"  # all else
)
)%>%
mutate(threshold_label = case_when(
threshold == t_crit_05 ~ "Differences between ERPs to Targets and Standards (Maximum Cluster−Level Mass, t threshold = 2.02",
threshold == t_crit_001 ~ "Differences between ERPs to Targets and Standards (Maximum Cluster−Level Mass, t threshold = 3.56"
))
electrode_coords <- data.frame(
electrode = c("FP1", "F3", "F7", "FC3", "C3", "C5", "P3", "P7", "PO7", "PO3",
"O1", "Oz", "Pz", "CPz", "FP2", "Fz", "F4", "F8", "FC4", "FCz",
"Cz", "C4", "C6", "P4", "P8", "PO8", "PO4", "O2"),
x = c(-0.23, -0.50, -0.71, -0.50, -0.71, -0.87, -0.50, -0.71, -0.38, -0.23,
-0.13, 0.00, 0.00, 0.00, 0.23, 0.00, 0.50, 0.71, 0.50, 0.00,
0.00, 0.71, 0.87, 0.50, 0.71, 0.38, 0.23, 0.13),
y = c(0.91, 0.85, 0.71, 0.45, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91,
-0.98, -1.00, -0.50, 0.00, 0.91, 0.85, 0.85, 0.71, 0.45, 0.53,
0.00, 0.00, -0.23, -0.45, -0.71, -0.92, -0.91, -0.98)
)
runs_df <- raster_df %>%
# keep only points where the test-statistic exceeds the positive OR negative cutoff
filter(t_obs >  threshold | t_obs < -threshold) %>%
# keep only the columns we need for clustering
select(channel, time, t_obs)
library(dplyr)
library(igraph)
# 1) Define channel adjacency from your coords
coords <- electrode_coords
# compute pairwise distances
dist_mat <- as.matrix(dist(coords[, c("x","y")]))
# pick a distance threshold (e.g. 0.5 units) so that each electrode has ~4–6 neighbors
adj_thresh <- 0.5
adj_pairs <- which(dist_mat < adj_thresh & dist_mat > 0, arr.ind = TRUE)
# turn that into a data.frame of edges
chan_edges <- tibble(
from = coords$electrode[adj_pairs[,1]],
to   = coords$electrode[adj_pairs[,2]]
)
# 2) Prepare your “nodes” = each suprathreshold point
#    give each a unique ID = paste(channel, time)
nodes <- runs_df %>%
mutate(node_id = paste(channel, time)) %>%
select(node_id, channel, time, t_obs)
# 3) Build edges between nodes
#  a) temporal edges: same channel, time difference = 1 bin
temp_edges <- nodes %>%
group_by(channel) %>%
arrange(time) %>%
mutate(next_id = lead(node_id), next_time = lead(time)) %>%
filter(!is.na(next_id) & next_time == time + unique(diff(sort(unique(runs_df$time))))) %>%
transmute(from = node_id, to = next_id)
#  b) spatial edges: same time, channels in chan_edges
# join nodes to chan_edges at each time‐point
spat_edges <- nodes %>%
select(node_id, channel, time) %>%
inner_join(chan_edges, by = c("channel" = "from")) %>%       # node’s channel -> from
rename(neigh_chan = to) %>%
inner_join(nodes %>% select(node_id, channel),                 # find node at neigh_chan
by = c("neigh_chan" = "channel", "time" = "time")) %>%
transmute(from = node_id.x, to = node_id.y)
#| include: false
library(tidyverse)
library(ggpubr)
library(patchwork)
library(dplyr)
library(igraph)
#| echo: false
erp_load <- function(path) {
filenames <- list.files(path = path, full.names = TRUE)
lista_dati <- vector("list", length(filenames))
for (i in seq_along(filenames)) {
tempdata <- read.table(filenames[i], header = TRUE)
temp_long <- tempdata %>%
pivot_longer(cols = -time, names_to = "channel", values_to = "value") %>%
mutate(
id = ceiling(i / 4),
condition = c("Cars", "Faces", "ScrambledCars", "ScrambledFaces")[(i - 1) %% 4 + 1]
)
lista_dati[[i]] <- temp_long  # Salva il tibble trasformato
}
df_finale <- bind_rows(lista_dati)  # Combina tutti i dati
return(df_finale)
rm(lista_dati)
}
df <- erp_load("C:/Users/david/Downloads/ERPDataforstudents")
df <- df %>%
filter(condition %in% c("Faces", "ScrambledFaces"))
#| echo: false
#| label: fig-erp-plot
#| fig-cap: "**Figura 1.** ERP (*Event-related potentials*) per *Faces* e *ScrambledFaces* in un compito visivo con 28 elettrodi sullo scalpo. Si noti che il positivo è visualizzato in basso sull'asse y, una convenzione comune nella ricerca ERP."
#| fig-width: 12
#| fig-height: 9
#| fig-align: "center"
# assume your data.frame is called `df`
# with columns: time (numeric, ms), id (factor/character),
# channel (factor/character), value (numeric, μV), condition (factor with levels "face","scrambled")
# 1) make sure channel is a factor with a sensible plotting order
#    here you could reorder levels to match your scalp‐map layout
electrode_order <- c(
# Frontal Left
"FP1", "F7", "F3", "FC3",
# Frontal Midline
"Fz", "FCz",
# Frontal Right
"FP2", "F8", "F4", "FC4",
# Central Left
"C3", "C5",
# Central Midline
"Cz", "CPz",
# Central Right
"C4", "C6",
# Parietal Left
"P3", "P7",
# Parietal Midline
"Pz",
# Parietal Right
"P4", "P8",
# Occipital/Posterior
"PO7", "PO3", "O1",
"PO8", "PO4", "O2",
"Oz"
)
df <- df %>%
mutate(channel = factor(channel, levels=electrode_order))
# 2) compute grand‐average ± SE per time × channel × condition
df_summary <- df %>%
group_by(channel, condition, time) %>%
summarize(
mean_uV = mean(value),
se_uV   = sd(value) / sqrt(n_distinct(id)),
.groups = "drop"
)
# 3) draw
p <- ggplot(df_summary, aes(x = time, y = mean_uV, color = condition,fill=condition)) +
# Add reference lines at 0 (before data lines to keep them in the background)
geom_vline(xintercept = 0, linewidth = 0.3) +
geom_hline(yintercept = 0, linewidth = 0.3) +
# waveform lines
geom_line(linewidth = .6) +
# invert y-axis so negative appears up
scale_y_reverse() +
# one panel per electrode
facet_wrap(~ channel, ncol = 6) +
# labels & theme
labs(
x = "Time (ms)",
y = "Amplitude (μV)\n(neg up)",
color = "Condition",
fill  = "Condition"
) +
# Theme with larger text
theme_minimal(base_size = 14) +  # Base font size (default: 11)
theme(
# Title and axis labels
plot.title = element_text(size = 16, face = "bold", hjust = 0.5),  # Centered bold title
axis.title = element_text(size = 16),  # Axis titles
axis.text = element_text(size = 12),   # Axis numbers (e.g., time ticks)
# Facet labels (electrode names)
strip.text = element_text(size = 12),
# Legend
legend.position = "bottom",
legend.text = element_text(size = 16),  # Condition labels
legend.title = element_text(size = 16),  # "Condition" title
)
# 4) print
print(p)
??obs2coeffWithin
library(flip)
dataCoeff=obs2coeffWithin(value~ channel*condition,data=df,units=~id)
colnames(dataCoeff$coeffWithin)
unique(df$channel)
Y=dataCoeff$coeffWithin[,29]+cbind(ChanFP1=0,dataCoeff$coeffWithin[,30:56])
colnames(Y)=gsub(":Condition.","",colnames(Y))
colnames(Y)
colnames(Y)=gsub(":condition.","",colnames(Y))
colnames(Y)
Y=dataCoeff$coeffWithin[,29]+cbind(ChanFP1=0,dataCoeff$coeffWithin[,30:56])
colnames(Y)
colnames(Y)=gsub(":conditionScrambledFaces","",colnames(Y))
colnames(Y)
res=flip(Y,perms=10000)
res=flip.adjust(res)
summary(res)
library(eegkit)
install.packages("eegkit")
library(eegkit)
# get the a z value from the adjusted p-value for each channel, just for visual purposes:
pvals=getFlip(res,"Adjust:maxT")
rownames(pvals)=gsub("Chan","",rownames(pvals))
# match to eeg coordinates
data(eegcoord)
cidx <- match(rownames(pvals),rownames(eegcoord))
# plot t-stat in 2d
eegspace(eegcoord[cidx,4:5],-log10(pvals[,1]),cex.point = 3,colorlab="-log10(adj-p)",mycolors=heat.colors(4)
)
# plot t-stat in 2d
eegspace(eegcoord[cidx,4:5],-log10(pvals[,1]),cex.point = 3,colorlab="-log10(adj-p)",mycolors=heat.colors(4))
# plot t-stat in 2d
eegspace(eegcoord[cidx,4:5],-log10(pvals[,1]),cex.point = 3,colorlab="-log10(adj-p)",mycolors=heat.colors(4))
eegcoord
cidx
rownames(pvals)
rownames(pvals)=gsub("channel","",rownames(pvals))
cidx <- match(rownames(pvals),rownames(eegcoord))
# plot t-stat in 2d
eegspace(eegcoord[cidx,4:5],-log10(pvals[,1]),cex.point = 3,colorlab="-log10(adj-p)",mycolors=heat.colors(4))
summary(res)
mod_mix=lmer(value~ channel*ondition +(channel|id),data=dati)
library(lme4)
mod_mix=lmer(value~ channel*ondition +(channel|id),data=dati)
mod_mix=lmer(value~ channel*ondition +(channel|id),data=df)
mod_mix=lmer(value~ channel*condition +(channel|id),data=df)
dati_n170 <- df %>%
filter(time >= 150, time <= 190, channel %in% all_channels) %>%
group_by(channel, condition) %>%
summarise(
mean_amp = mean(value, na.rm = TRUE),
sd_amp = sd(value, na.rm = TRUE),
n = n(),
sem_amp = sd_amp / sqrt(n),
.groups = "drop"
)
df
dati_n170 <- df %>%
filter(time >= 150, time <= 190, channel %in% all_channels) %>%
group_by(channel, condition) %>%
summarise(
mean_amp = mean(value, na.rm = TRUE),
sd_amp = sd(value, na.rm = TRUE),
n = n(),
sem_amp = sd_amp / sqrt(n),
.groups = "drop"
)
df$time
dati_n170 <- df %>%
filter(time >= 150, time <= 190) %>%
group_by(channel, condition) %>%
summarise(
mean_amp = mean(value, na.rm = TRUE),
sd_amp = sd(value, na.rm = TRUE),
n = n(),
sem_amp = sd_amp / sqrt(n),
.groups = "drop"
)
hist(df$time)
df
dati_n170 <- df %>%
filter(time >= 150, time <= 190) %>%
group_by(channel, condition) %>%
summarise(
mean_amp = mean(value, na.rm = TRUE),
sd_amp = sd(value, na.rm = TRUE),
n = n(),
sem_amp = sd_amp / sqrt(n),
.groups = "drop"
)
df_n170 <- df %>%
filter(time >= 150, time <= 190) %>%
group_by(channel, condition) %>%
summarise(
mean_amp = mean(value, na.rm = TRUE),
sd_amp = sd(value, na.rm = TRUE),
n = n(),
sem_amp = sd_amp / sqrt(n),
.groups = "drop"
)
str(df$time)
library(lme4)
df$time <- as.numeric(df$time)
df_n170 <- df %>%
filter(time >= 150, time <= 190) %>%
group_by(channel, condition) %>%
summarise(
mean_amp = mean(value, na.rm = TRUE),
sd_amp = sd(value, na.rm = TRUE),
n = n(),
sem_amp = sd_amp / sqrt(n),
.groups = "drop"
)
#| include: false
library(tidyverse)
library(ggpubr)
library(patchwork)
library(dplyr)
library(igraph)
#| echo: false
erp_load <- function(path) {
filenames <- list.files(path = path, full.names = TRUE)
lista_dati <- vector("list", length(filenames))
for (i in seq_along(filenames)) {
tempdata <- read.table(filenames[i], header = TRUE)
temp_long <- tempdata %>%
pivot_longer(cols = -time, names_to = "channel", values_to = "value") %>%
mutate(
id = ceiling(i / 4),
condition = c("Cars", "Faces", "ScrambledCars", "ScrambledFaces")[(i - 1) %% 4 + 1]
)
lista_dati[[i]] <- temp_long  # Salva il tibble trasformato
}
df_finale <- bind_rows(lista_dati)  # Combina tutti i dati
return(df_finale)
rm(lista_dati)
}
df <- erp_load("C:/Users/david/Downloads/ERPDataforstudents")
df <- df %>%
filter(condition %in% c("Faces", "ScrambledFaces"))
#| echo: false
erp_load <- function(path) {
filenames <- list.files(path = path, full.names = TRUE)
lista_dati <- vector("list", length(filenames))
for (i in seq_along(filenames)) {
tempdata <- read.table(filenames[i], header = TRUE)
temp_long <- tempdata %>%
pivot_longer(cols = -time, names_to = "channel", values_to = "value") %>%
mutate(
id = ceiling(i / 4),
condition = c("Cars", "Faces", "ScrambledCars", "ScrambledFaces")[(i - 1) %% 4 + 1]
)
lista_dati[[i]] <- temp_long  # Salva il tibble trasformato
}
df_finale <- bind_rows(lista_dati)  # Combina tutti i dati
return(df_finale)
rm(lista_dati)
}
df <- erp_load("C:/Users/david/Downloads/ERPDataforstudents")
df <- df %>%
filter(condition %in% c("Faces", "ScrambledFaces"))
df
#| include: false
library(tidyverse)
library(ggpubr)
library(patchwork)
library(dplyr)
library(igraph)
#| echo: false
erp_load <- function(path) {
filenames <- list.files(path = path, full.names = TRUE)
lista_dati <- vector("list", length(filenames))
for (i in seq_along(filenames)) {
tempdata <- read.table(filenames[i], header = TRUE)
temp_long <- tempdata %>%
pivot_longer(cols = -time, names_to = "channel", values_to = "value") %>%
mutate(
id = ceiling(i / 4),
condition = c("Cars", "Faces", "ScrambledCars", "ScrambledFaces")[(i - 1) %% 4 + 1]
)
lista_dati[[i]] <- temp_long  # Salva il tibble trasformato
}
df_finale <- bind_rows(lista_dati)  # Combina tutti i dati
return(df_finale)
rm(lista_dati)
}
df <- erp_load("C:/Users/david/Downloads/ERPDataforstudents")
df <- df %>%
filter(condition %in% c("Faces", "ScrambledFaces"))
